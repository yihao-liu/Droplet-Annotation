"""
Script Name: Droplet Tracking Annotation Tool
Description: This script provides an interactive tool to annotate and refine droplet tracking results generated by the Matlab script.

Author: Yihao Liu
Email: yihao_work@outlook.com
Last Modified: 27-11-2023
"""

import os
import nd2
import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.widgets import Button
import pandas as pd
import matplotlib.widgets as widgets
import argparse
from pathlib import Path


PROJECT_PATH = Path(os.getcwd())
DATA_PATH = Path(PROJECT_PATH / "data")
if not os.path.exists(DATA_PATH):
    os.makedirs(DATA_PATH)
RESULT_PATH = Path(PROJECT_PATH / "results")
if not os.path.exists(RESULT_PATH):
    os.makedirs(RESULT_PATH)


parser = argparse.ArgumentParser(
    description="Annotation widget for droplet tracking refinement. The script works with the output of the Matlab script.")
parser.add_argument("image_name", type=str,
                    help="Name of the image for processing")
parser.add_argument("-v", "--verbose", type=int, choices=[0, 1], default=0,
                    help="Control the verbosity of the script, 0 for silent, 1 for verbose. Default is 0.")
args = parser.parse_args()


def get_image_as_ndarray(frames, channels, path_to_image, allFrames=True, allChannels=False):

    f = nd2.ND2File(path_to_image)

    nr_frames = f.sizes['T']
    nr_channels = f.sizes['C']
    nr_rows = f.sizes['Y']
    nr_cols = f.sizes['X']

    print('Nr frames: ' + str(nr_frames))
    print('Nr channels: ' + str(nr_channels))
    print('Image dimensions: ' + str(nr_rows) + 'x' + str(nr_cols))

    channel_idx_lookup = {}
    if allChannels:
        channels = []
    print('Channel names:')
    for c in f.metadata.channels:
        channelname = c.channel.name
        if allChannels:
            channels.append(channelname)
        print('\t' + channelname)
        channelidx = c.channel.index
        if (channelname in channels):
            channel_idx_lookup[channelname] = channelidx
    channel_idx_precompute = []
    for ch_name in channels:
        channel_idx_precompute.append(channel_idx_lookup[ch_name])
    if allFrames:
        frames = range(nr_frames)
    fullimage = f.asarray()
    output = (fullimage[frames, :, :, :])[:, channel_idx_precompute, :, :]
    return output


def process_dataframe(df):
    # Filter and keep only columns that contain "TrueCentroid" or "DiameterMicrons"
    centroid_columns = [col for col in df.columns if "TrueCentroid" in col]
    keep_columns = centroid_columns + ['DiameterMicrons']
    print(keep_columns)
    df = df[keep_columns]

    # Rename "TrueCentroid" columns sequentially to "center_row_n" and "center_col_n"
    rename_mapping = {old_name: f'center_{"row" if i % 2 == 0 else "col"}_{i // 2 + 1}'
                      for i, old_name in enumerate(centroid_columns)}

    # Rename "DiameterMicrons" to "d_diameter"
    rename_mapping['DiameterMicrons'] = 'd_diameter'

    df = df.rename(columns=rename_mapping)

    return df


# Load the refined tracking data
# Modify function to load images for a given row
def load_images_for_row(row):
    images = []
    d_diameter = row["d_diameter"]
    row.drop("d_diameter")

    for i in range(1, int(len(row)/2)+1):  # Assuming there are 9 pairs of centroids
        row_key = f"center_row_{i}"
        col_key = f"center_col_{i}"

        # Calculate the slices for each centroid
        x_slice = slice(int(max(
            x_min, row[row_key] - d_diameter/2)), int(min(x_max, row[row_key] + d_diameter/2)))
        y_slice = slice(int(max(
            y_min, row[col_key] - d_diameter/2)), int(min(y_max, row[col_key] + d_diameter/2)))
        for j in range(full_image.shape[1]):
            image = full_image[i-1, j, x_slice, y_slice]
            image = cv.resize(image, (64, 64))
            images.append(image)
        flag_droplet = True
    return images, flag_droplet

# Update display for a new row


def update_display(row):
    images, flag_droplet = load_images_for_row(row)
    for col_idx, image_group in enumerate(zip(*[images[i::n_rows] for i in range(n_rows)])):
        for row_idx, img in enumerate(image_group):
            axarr[row_idx, col_idx].imshow(img, vmin=0)

    # for col_idx, (img_0, img_1, img_2, img_3, img_4) in enumerate(zip(images[0::5], images[1::5], images[2::5], images[3::5], images[4::5])):
    #     axarr[0, col_idx].imshow(img_0, vmin=0)
    #     axarr[1, col_idx].imshow(img_1, vmin=0)
    #     axarr[2, col_idx].imshow(img_2, vmin=0)
    #     axarr[3, col_idx].imshow(img_3, vmin=0)
    #     axarr[4, col_idx].imshow(img_4, vmin=0)
    #     if col_idx == 0:
    #         # the original order is DAPI, FITC, TRITC, Cy5, BF
    #         axarr[0, col_idx].set_title("DAPI", fontsize=10)
    #         axarr[1, col_idx].set_title("FITC", fontsize=10)
    #         axarr[2, col_idx].set_title("TRITC", fontsize=10)
    #         axarr[3, col_idx].set_title("Cy5", fontsize=10)
    #         axarr[4, col_idx].set_title("BF", fontsize=10)
    plt.draw()
    # put update_row_info() here
    update_row_info()
    # Check if current row has a label and display it
    update_label_text()
    # current_label = final_results.loc[refined_df.index[current_row_idx], 'Label']
    # label_text.set_text(current_label if not pd.isna(current_label) else '')


def on_true_clicked(event):
    global current_row_idx
    if args.verbose == 1:
        print(f"Row {current_row_idx} is marked true.")

    # Mark the current row for keeping, and add label 'True'
    rows_true.append(refined_df.index[current_row_idx])
    tmp = refined_df.index[current_row_idx]
    if tmp in rows_false:
        rows_false.remove(tmp)
    elif tmp in rows_unsure:
        rows_unsure.remove(tmp)

    if current_row_idx < len(refined_df) - 1:
        current_row_idx += 1
        update_display(refined_df.iloc[current_row_idx])
        # update_row_info()
        # label_text.set_text('True')  # Update label text


def on_unsure_clicked(event):
    global current_row_idx
    if args.verbose == 1:
        print(f"Row {current_row_idx} is marked unsure.")
    rows_unsure.append(refined_df.index[current_row_idx])
    tmp = refined_df.index[current_row_idx]
    if tmp in rows_false:
        rows_false.remove(tmp)
    elif tmp in rows_true:
        rows_true.remove(tmp)

    if current_row_idx < len(refined_df) - 1:
        current_row_idx += 1
        update_display(refined_df.iloc[current_row_idx])
        # update_row_info()
        # label_text.set_text('Unsure')  # Update label text


def on_false_clicked(event):
    global current_row_idx
    if args.verbose == 1:
        print(f"Row {current_row_idx} is marked false.")

    # Mark the current row for deletion, and add label 'False'
    rows_false.append(refined_df.index[current_row_idx])
    tmp = refined_df.index[current_row_idx]
    if tmp in rows_true:
        rows_true.remove(tmp)
    elif tmp in rows_unsure:
        rows_unsure.remove(tmp)

    if current_row_idx < len(refined_df) - 1:
        current_row_idx += 1
        update_display(refined_df.iloc[current_row_idx])
        # update_row_info()
        # label_text.set_text('False')  # Update label text


def on_delete_clicked(event):
    global current_row_idx
    if args.verbose == 1:
        print(f"Label of row {current_row_idx} has be removed.")
    # If the current row is marked for deletion, unmark it
    if current_row_idx in rows_false:
        rows_false.remove(current_row_idx)
    elif current_row_idx in rows_true:
        rows_true.remove(current_row_idx)
    elif current_row_idx in rows_unsure:
        rows_unsure.remove(current_row_idx)
    # if we need to update the label text
    update_display(refined_df.iloc[current_row_idx])


def on_prev_clicked(event):
    global current_row_idx
    if current_row_idx > 0:
        current_row_idx -= 1
        update_display(refined_df.iloc[current_row_idx])
        # update_row_info()


def on_next_clicked(event):
    global current_row_idx
    if current_row_idx < len(refined_df) - 1:
        current_row_idx += 1
        update_display(refined_df.iloc[current_row_idx])
        # update_row_info()


def on_close(event):
    # Label the rows in rows_false with "False", the rows in rows_true with "True", and the rows in rows_unsure with "Unsure"
    final_results.loc[rows_false, 'Label'] = "False"
    final_results.loc[rows_true, 'Label'] = "True"
    final_results.loc[rows_unsure, 'Label'] = "Unsure"

    # Save the refined_df to CSV
    final_results.to_csv(
        f"{RESULT_PATH}/refined_results_{IMAGE_NAME}.csv", index=False)
    print('Saved the refined tracked droplet data after labeling.')


def on_key(event):
    """Keyboard interaction."""
    if event.key == 'right':
        on_next_clicked(event)
    elif event.key == 'left':
        on_prev_clicked(event)
    elif event.key == '1':
        on_true_clicked(event)
    elif event.key == '2':
        on_unsure_clicked(event)
    elif event.key == '3':
        on_false_clicked(event)
    elif event.key == '4':
        on_delete_clicked(event)


def update_row_info():
    row_info_text.set_text(f"Row: {current_row_idx + 1} / {len(refined_df)}")


def update_label_text():
    if current_row_idx in rows_false:
        label_text.set_text('False')
    elif current_row_idx in rows_true:
        label_text.set_text('True')
    elif current_row_idx in rows_unsure:
        label_text.set_text('Unsure')
    else:
        label_text.set_text('')


def on_submit(text_box, text):
    """Jump to specified row when user submits a value in the TextBox."""
    global current_row_idx
    # Check if text is not empty
    if text.strip():  # This removes any leading/trailing whitespace and checks if text is not just whitespace
        try:
            # Convert text input to integer and adjust for 0-based indexing
            new_idx = int(text) - 1

            # Check if the new index is within the dataframe's bounds
            if 0 <= new_idx < len(refined_df):
                current_row_idx = new_idx
                update_display(refined_df.iloc[current_row_idx])
                # update_row_info()
            else:
                print(f"Row {text} is out of range!")
        except ValueError:
            print("Please enter a valid row number.")
    # Clear the contents of the TextBox after processing the input
    text_box.set_val('')


IMAGE_NAME = args.image_name

image_path = os.path.join(DATA_PATH, IMAGE_NAME)
# Read the image without any processing
full_image = get_image_as_ndarray(
    [0], ['BF', 'DAPI'], f"{image_path}.nd2", allFrames=True, allChannels=True)
# For Matlab script results
refined_df = pd.read_excel(os.path.join(
    RESULT_PATH, f"results_{IMAGE_NAME}.xlsx"), index_col=0)
# drop unnecessary columns and rename columns
refined_df = process_dataframe(refined_df)

# For Python script results
# refined_df = pd.read_csv(os.path.join(
#     RESULT_PATH, f"results_{IMAGE_NAME}.csv"), index_col=0)
# refined_df["d_diameter"] = 40

if os.path.exists(f"{RESULT_PATH}/refined_results_{IMAGE_NAME}.csv"):
    final_results = pd.read_csv(
        f"{RESULT_PATH}/refined_results_{IMAGE_NAME}.csv")
else:
    final_results = refined_df.copy()
    final_results['Label'] = np.nan


x_min = 0
x_max = int(full_image.shape[-1])-1
y_min = 0
y_max = int(full_image.shape[-2])-1

# Button callback functions
current_row_idx = 0

# Create a list to keep track of rows
rows_false = []  # Marked for deletion, and will be used for training by increasing the distance among them
rows_true = []  # Marked for keeping, and will be used for training by decrease the ditance among them
# Marked for further inspection and the ditance among them will be kept the same
rows_unsure = []

n_cols = int((refined_df.shape[1]-1)/2)
n_rows = full_image.shape[1]
fig, axarr = plt.subplots(n_rows, n_cols, figsize=(15, 20))

# Remove axis for each subplot
for ax_row in axarr:
    for ax in ax_row:
        ax.axis('off')

# Add annotation to display the current label
label_text = fig.text(0.5, 0.95, '', ha='center', transform=fig.transFigure)
# Add annotation to display the current row info
row_info_text = fig.text(0.15, 0.95, '', transform=fig.transFigure)
# Display the initial label
update_label_text()
# Display the initial row info
update_row_info()
# Define a TextBox widget for user input
# Adjust position & size as needed
ax_textbox = plt.axes([0.8, 0.925, 0.1, 0.05])  # [x, y , width, height]
text_box = widgets.TextBox(ax_textbox, 'Jump to Row:')
# Assuming text_box is created as mentioned in the previous response
text_box.on_submit(lambda text: on_submit(text_box, text))

# Display the first row
update_display(refined_df.iloc[0])  # start with the first row

# Middle position of the figure's width
middle = 0.5

# Define button widths and offsets from the middle
button_width = 0.1
offset = 0.1
button_height = 0.05
button_space = 0.01  # Vertical space between buttons and plots

# Compute bottom position based on button's height and space from plots
bottom_position = button_space + button_height

# Define the button axes uniformly distributed
ax_prev = plt.axes([middle - 3*offset, bottom_position,
                    button_width, button_height])
ax_true = plt.axes([middle - 2*offset, bottom_position,
                    button_width, button_height])
ax_unsure = plt.axes([middle - offset, bottom_position,
                      button_width, button_height])
ax_false = plt.axes([middle, bottom_position, button_width, button_height])
ax_delete = plt.axes([middle + 1*offset, bottom_position,
                      button_width, button_height])
ax_next = plt.axes([middle + 2*offset, bottom_position,
                    button_width, button_height])

# Create buttons
btn_prev = Button(ax_prev, 'Prev')
btn_true = Button(ax_true, 'True (1)')
btn_unsure = Button(ax_unsure, 'Unsure (2)')
btn_false = Button(ax_false, 'False (3)')
btn_delete = Button(ax_delete, 'Delete (4)')
btn_next = Button(ax_next, 'Next')

# Link buttons to their callback functions
btn_prev.on_clicked(on_prev_clicked)
btn_true.on_clicked(on_true_clicked)
btn_unsure.on_clicked(on_unsure_clicked)
btn_false.on_clicked(on_false_clicked)
btn_delete.on_clicked(on_delete_clicked)
btn_next.on_clicked(on_next_clicked)

# Link the key event to the callback function
plt.gcf().canvas.mpl_connect('key_press_event', on_key)

# Connect the close event to the on_close function
plt.connect('close_event', on_close)

plt.show()
